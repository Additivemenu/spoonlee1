# 一、有限状态机（FSM）：确定性的基石

### **1.1 FSM的核心哲学与数学模型**

有限状态机不仅仅是技术实现，更是一种**确定性思维模型**。其数学定义为：

```

FSM = (S, Σ, δ, s₀, F)
其中：
S: 有限状态集合
Σ: 输入字母表（事件集合）  
δ: 状态转移函数 S × Σ → S
s₀: 初始状态
F: 接受状态集合
```

高中时的五点法似乎也对应一种状态机模型

- v1 初始状态
- v2终止状态
- a*t 相当于transition (event)

```tsx
     x
v1   a   v2
		 t
```

在前端语境下的映射：

```tsx

// 前端FSM的数学模型实现
class MathematicalFSM {
  constructor() {
    this.S = new Set(); // 状态集合  
    this.Σ = new Set(); // 事件集合  即合法的transitions 集合
    this.δ = new Map(); // 转移函数 state -> transitions, 即当前状态对应有哪几种transitions(event)的选项    
    this.s₀ = null;     // 初始状态
    this.F = new Set(); // 终态集合
  }

  // 验证FSM的完整性
  validate() {
    const violations = [];

    // 检查初始状态是否存在
    if (!this.S.has(this.s₀)) {
      violations.push('初始状态不在状态集合中');
    }

    // 检查转移函数的完备性
    for (const [state, transitions] of this.δ) {
      for (const event of this.Σ) {
        if (!transitions.has(event)) {
          violations.push(`状态 ${state} 对事件 ${event} 没有定义转移`);
        }
      }
    }

    return violations;
  }
}
```

### **1.2 企业级FSM实现：超越XState**

```tsx
// 类型安全的FSM实现
interface FSMConfig<TState extends string, TEvent extends string> {
  id: string;
  initial: TState;
  states: Record<TState, {
    on?: Partial<Record<TEvent, {
      target: TState;
      action?: (context: any) => void;
      guard?: (context: any) => boolean;
    }>>;
    entry?: (context: any) => void;
    exit?: (context: any) => void;
  }>;
  context?: any;
}

class EnterpriseFSM<TState extends string, TEvent extends string> {
  private currentState: TState;
  private context: any;
  private readonly config: FSMConfig<TState, TEvent>;
  private stateHistory: Array<{ state: TState; timestamp: number; event?: TEvent }> = [];

  // 状态转移监听器
  private listeners: Array<(transition: {
    from: TState;
    to: TState;
    event: TEvent;
    context: any;
  }) => void> = [];

  constructor(config: FSMConfig<TState, TEvent>) {
    this.config = config;
    this.currentState = config.initial;
    this.context = config.context || {};
    this.recordState('INIT');
  }

  // 发送事件触发状态转移
  async send(event: TEvent, payload?: any): Promise<boolean> {
    const currentStateConfig = this.config.states[this.currentState];
    const transitionConfig = currentStateConfig.on?.[event];

    if (!transitionConfig) {
      console.warn(`无定义转移: ${this.currentState} -> ${event}`);
      return false;
    }

    // 执行守卫条件检查
    if (transitionConfig.guard && !transitionConfig.guard(this.context)) {
      console.warn(`守卫条件阻止转移: ${this.currentState} -> ${event}`);
      return false;
    }

    const fromState = this.currentState;

    // 执行退出动作
    await this.executeStateAction('exit', fromState);

    // 执行转移动作
    if (transitionConfig.action) {
      await transitionConfig.action({ ...this.context, ...payload });
    }

    // 更新状态
    this.currentState = transitionConfig.target;

    // 执行进入动作  
    await this.executeStateAction('entry', this.currentState);

    // 记录状态历史
    this.recordState(event);

    // 通知监听器
    this.notifyListeners({
      from: fromState,
      to: this.currentState,
      event,
      context: this.context
    });

    return true;
  }

  private async executeStateAction(type: 'entry' | 'exit', state: TState) {
    const action = this.config.states[state]?.[type];
    if (action) {
      await action(this.context);
    }
  }

  private recordState(event?: TEvent) {
    this.stateHistory.push({
      state: this.currentState,
      timestamp: Date.now(),
      event
    });

    // 保持历史记录在合理范围内
    if (this.stateHistory.length > 1000) {
      this.stateHistory = this.stateHistory.slice(-500);
    }
  }

  // 时间旅行调试
  timeTravelTo(index: number) {
    if (index >= 0 && index < this.stateHistory.length) {
      const targetState = this.stateHistory[index];
      this.currentState = targetState.state;
      this.notifyListeners({
        from: this.currentState,
        to: targetState.state,
        event: 'TIME_TRAVEL' as TEvent,
        context: this.context
      });
    }
  }

  // 获取可达性分析
  getReachableStates(): Set<TState> {
    const visited = new Set<TState>();
    const queue: TState[] = [this.currentState];

    while (queue.length > 0) {
      const state = queue.shift()!;
      if (visited.has(state)) continue;

      visited.add(state);
      const stateConfig = this.config.states[state];

      if (stateConfig.on) {
        Object.values(stateConfig.on).forEach(transition => {
          if (!visited.has(transition.target)) {
            queue.push(transition.target);
          }
        });
      }
    }

    return visited;
  }
}

```

```tsx
// 实战：文档编辑器的状态管理
type EditorState = 'draft' | 'editing' | 'reviewing' | 'approved' | 'rejected' | 'published';
type EditorEvent = 'EDIT' | 'SUBMIT' | 'APPROVE' | 'REJECT' | 'PUBLISH' | 'RETURN';

const editorFSM = new EnterpriseFSM<EditorState, EditorEvent>({
  id: 'document-editor',
  initial: 'draft',
  context: {
    documentId: 'doc-123',
    version: 1,
    changes: []
  },
  states: {
    draft: {
      on: {
        EDIT: { target: 'editing' },
        SUBMIT: { 
          target: 'reviewing',
          guard: (ctx) => ctx.changes.length > 0,
          action: (ctx) => console.log('提交审核:', ctx.documentId)
        }
      },
      entry: (ctx) => console.log('进入草稿状态'),
      exit: (ctx) => console.log('退出草稿状态')
    },
    editing: {
      on: {
        SUBMIT: { target: 'reviewing' },
        RETURN: { target: 'draft' }
      }
    },
    reviewing: {
      on: {
        APPROVE: { target: 'approved' },
        REJECT: { target: 'rejected' }
      }
    },
    approved: {
      on: {
        PUBLISH: { target: 'published' },
        RETURN: { target: 'editing' }
      }
    },
    rejected: {
      on: {
        EDIT: { target: 'editing' }
      }
    },
    published: {
      // 终态，无转移
    }
  }
});
```