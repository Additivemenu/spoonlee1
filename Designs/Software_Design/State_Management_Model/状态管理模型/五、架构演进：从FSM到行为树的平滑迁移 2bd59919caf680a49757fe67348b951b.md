# 五、架构演进：从FSM到行为树的平滑迁移

### **5.1 混合架构策略**

在实际项目中，完全重写现有FSM系统可能不现实。我们可以采用混合架构实现平滑迁移。

```tsx

// FSM与行为树的桥梁
class FSMToBTAdapter {
  private fsm: EnterpriseFSM<any, any>;
  private behaviorTree: BehaviorTreeNode;

  constructor(fsm: EnterpriseFSM<any, any>, bt: BehaviorTreeNode) {
    this.fsm = fsm;
    this.behaviorTree = bt;
  }

  // 将FSM状态映射到行为树条件
  createFSMCondition(state: string): ConditionNode {
    return new ConditionNode(
      (blackboard) => this.fsm.getState() === state,
      `FSM状态为: ${state}`
    );
  }

  // 将FSM事件映射到行为树动作
  createFSMAction(event: string, payload?: any): ActionNode {
    return new ActionNode(
      async (blackboard) => {
        const success = await this.fsm.send(event, payload);
        return success ? NodeStatus.SUCCESS : NodeStatus.FAILURE;
      },
      `发送FSM事件: ${event}`
    );
  }

  // 创建混合决策节点
  createHybridDecision(
    fsmState: string,
    btCondition: (bb: Blackboard) => boolean,
    actions: BehaviorTreeNode[]
  ): SelectorNode {
    return new SelectorNode([
      new SequenceNode([
        this.createFSMCondition(fsmState),
        new ConditionNode(btCondition, '行为树条件检查'),
        ...actions
      ]),
      // 备用逻辑...
    ]);
  }
}

// 渐进式迁移策略
class IncrementalMigrationStrategy {
  private originalFSM: EnterpriseFSM<any, any>;
  private hybridSystem: FSMToBTAdapter;
  private migrationPhase: 'analysis' | 'hybrid' | 'complete' = 'analysis';

  constructor(fsm: EnterpriseFSM<any, any>) {
    this.originalFSM = fsm;
    this.hybridSystem = this.createHybridSystem();
  }

  private createHybridSystem(): FSMToBTAdapter {
    // 分析FSM复杂度，决定迁移策略
    const complexity = this.analyzeFSMComplexity();

    if (complexplicity.stateCount < 10) {
      // 简单FSM，直接转换为行为树
      return this.convertSimpleFSM();
    } else {
      // 复杂FSM，采用混合策略
      return this.createComplexHybrid();
    }
  }

  private analyzeFSMComplexity(): { stateCount: number; transitionCount: number; complexity: number } {
    // 分析FSM的复杂度指标
    return {
      stateCount: 0, // 实际实现中计算状态数量
      transitionCount: 0, // 转移数量
      complexity: 0 // 复杂度评分
    };
  }

  // 执行迁移
  async executeMigration(): Promise<void> {
    console.log('开始渐进式迁移...');

    // 阶段1: 并行运行，收集数据
    await this.parallelRunPhase();

    // 阶段2: 逐步切换流量
    await this.gradualCutoverPhase();

    // 阶段3: 完全迁移
    await this.completeMigrationPhase();

    console.log('迁移完成');
  }

  private async parallelRunPhase(): Promise<void> {
    console.log('阶段1: 并行运行');

    // 同时运行FSM和行为树，比较结果
    const testCases = this.generateTestCases();

    for (const testCase of testCases) {
      const fsmResult = await this.runFSMTestCase(testCase);
      const btResult = await this.runBTTestCase(testCase);

      this.compareResults(fsmResult, btResult, testCase);
    }
  }
}
```