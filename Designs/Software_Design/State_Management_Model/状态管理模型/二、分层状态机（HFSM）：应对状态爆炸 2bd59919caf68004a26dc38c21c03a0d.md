# 二、分层状态机（HFSM）：应对状态爆炸

### **2.1 状态嵌套与层次化设计**

当简单FSM面临状态爆炸问题时，分层状态机通过**父子状态关系**和**历史状态**等概念提供解决方案

```tsx

// 分层状态机实现
interface HFSMState<T extends string> {
  id: T;
  initial?: T; // 子状态机的初始状态
  states?: Record<string, HFSMState<any>>;
  on?: Record<string, any>;
}

class HierarchicalFSM {
  private currentStatePath: string[] = [];
  private stateStack: Array<{
    state: string;
    history?: string; // 历史状态记录
  }> = [];

  // 解析状态路径 'parent.child.grandchild'
  private resolveStatePath(statePath: string): { state: any; path: string[] } {
    const path = statePath.split('.');
    let current = this.config.states;

    for (const segment of path) {
      if (current[segment]?.states) {
        current = current[segment].states!;
      } else {
        throw new Error(`状态路径不存在: ${statePath}`);
      }
    }

    return { state: current[path[path.length - 1]], path };
  }

  // 进入分层状态
  private enterState(statePath: string) {
    const { path } = this.resolveStatePath(statePath);

    // 退出当前状态
    this.exitCurrentState();

    // 进入新状态及其所有父状态
    let currentPath = '';
    for (let i = 0; i < path.length; i++) {
      currentPath = i === 0 ? path[i] : `${currentPath}.${path[i]}`;

      const stateConfig = this.resolveStatePath(currentPath).state;

      // 执行进入动作
      if (stateConfig.entry) {
        stateConfig.entry(this.context);
      }

      // 如果是复合状态且有初始状态，进入初始子状态
      if (stateConfig.states && stateConfig.initial) {
        const childPath = `${currentPath}.${stateConfig.initial}`;
        this.enterState(childPath);
        break;
      }
    }

    this.currentStatePath = path;
  }

  // 处理分层事件传播
  private handleEvent(event: string, payload?: any): boolean {
    // 从当前状态开始，向上冒泡处理事件
    let currentPath = this.currentStatePath.join('.');

    while (currentPath) {
      const stateConfig = this.resolveStatePath(currentPath).state;

      if (stateConfig.on?.[event]) {
        const transition = stateConfig.on[event];

        // 执行转移
        if (transition.action) {
          transition.action(this.context);
        }

        this.enterState(transition.target);
        return true;
      }

      // 向上冒泡到父状态
      const pathSegments = currentPath.split('.');
      pathSegments.pop();
      currentPath = pathSegments.join('.');
    }

    return false;
  }
}

// 实战：智能家居控制系统
const smartHomeHFSM = {
  initial: 'off',
  states: {
    off: {
      on: { POWER_ON: 'on' }
    },
    on: {
      initial: 'idle',
      states: {
        idle: {
          on: {
            START_CLEANING: 'cleaning',
            START_SECURITY: 'security'
          }
        },
        cleaning: {
          initial: 'mapping',
          states: {
            mapping: {
              on: { MAPPING_COMPLETE: 'cleaning_rooms' }
            },
            cleaning_rooms: {
              on: { CLEANING_COMPLETE: 'returning' }
            },
            returning: {
              on: { DOCKED: 'idle' }
            }
          }
        },
        security: {
          on: {
            INTRUSION_DETECTED: 'alert',
            DISABLE_SECURITY: 'idle'
          }
        },
        alert: {
          on: {
            RESET_ALARM: 'security'
          }
        }
      },
      on: {
        POWER_OFF: 'off'
      }
    }
  }
};
```

### **2.2 历史状态的深度实现**

```tsx
// 历史状态管理器
class HistoryStateManager {
  private history: Map<string, string> = new Map(); // statePath -> lastActiveChild

  // 记录状态历史
  recordHistory(statePath: string, activeChild: string) {
    this.history.set(statePath, activeChild);
  }

  // 恢复历史状态
  restoreHistory(statePath: string): string | null {
    return this.history.get(statePath) || null;
  }

  // 深度历史恢复
  deepRestore(statePath: string): string[] {
    const restoredPath: string[] = [];
    let currentPath = statePath;

    while (currentPath) {
      const historyState = this.restoreHistory(currentPath);
      if (historyState) {
        currentPath = `${currentPath}.${historyState}`;
        restoredPath.push(currentPath);
      } else {
        break;
      }
    }

    return restoredPath;
  }
}

// 增强型HFSM with历史状态
class HFSMWithHistory extends HierarchicalFSM {
  private historyManager = new HistoryStateManager();

  protected enterState(statePath: string) {
    const { path } = this.resolveStatePath(statePath);

    // 检查是否需要恢复历史状态
    const parentPath = path.slice(0, -1).join('.');
    if (parentPath) {
      const historyState = this.historyManager.restoreHistory(parentPath);
      if (historyState && path[path.length - 1] === historyState) {
        // 这是历史状态的恢复，继续深度恢复
        const deepPath = this.historyManager.deepRestore(statePath);
        if (deepPath.length > 0) {
          super.enterState(deepPath[deepPath.length - 1]);
          return;
        }
      }
    }

    super.enterState(statePath);

    // 记录历史
    if (path.length > 1) {
      const parentPath = path.slice(0, -1).join('.');
      this.historyManager.recordHistory(parentPath, path[path.length - 1]);
    }
  }
}
```