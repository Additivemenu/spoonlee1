# 四、实战：智能表单决策引擎

### **4.1 复杂表单场景分析**

想象一个企业级贷款申请系统，包含：

- 动态字段显示/隐藏•多步骤表单流程•实时验证与计算•条件性跳转逻辑•异步数据依赖

```tsx

// 贷款申请行为树
class LoanApplicationBT {
  private blackboard: Blackboard;
  private behaviorTree: BehaviorTreeNode;

  constructor() {
    this.blackboard = new Blackboard();
    this.initializeBlackboard();
    this.behaviorTree = this.buildBehaviorTree();
  }

  private initializeBlackboard() {
    // 初始化表单数据
    this.blackboard.set('currentStep', 'basicInfo');
    this.blackboard.set('formData', {});
    this.blackboard.set('validationErrors', {});
    this.blackboard.set('isSubmitting', false);

    // 观察数据变化
    this.blackboard.observe('currentStep', (step) => {
      console.log(`步骤变更: ${step}`);
      this.updateUI();
    });
  }

  private buildBehaviorTree(): BehaviorTreeNode {
    return new SequenceNode([
      // 步骤1: 基本信息收集
      this.buildBasicInfoStep(),

      // 步骤2: 根据贷款类型决定后续流程
      new SelectorNode([
        this.buildPersonalLoanFlow(),
        this.buildBusinessLoanFlow(),
        this.buildMortgageFlow()
      ]),

      // 步骤3: 最终提交
      this.buildSubmissionStep()
    ]);
  }

  private buildBasicInfoStep(): BehaviorTreeNode {
    return new SequenceNode([
      new ConditionNode(
        (bb) => bb.get('currentStep') === 'basicInfo',
        '检查是否在基本信息步骤'
      ),

      // 验证基本信息
      new SequenceNode([
        new ConditionNode(
          (bb) => this.validateName(bb.get('formData.name')),
          '验证姓名'
        ),
        new ConditionNode(
          (bb) => this.validateEmail(bb.get('formData.email')),
          '验证邮箱'
        ),
        new ConditionNode(
          (bb) => this.validateAge(bb.get('formData.age')),
          '验证年龄'
        )
      ]),

      // 进入下一步
      new ActionNode((bb) => {
        bb.set('currentStep', 'loanType');
        return NodeStatus.SUCCESS;
      }, '进入贷款类型选择')
    ]);
  }

  private buildPersonalLoanFlow(): BehaviorTreeNode {
    return new SequenceNode([
      new ConditionNode(
        (bb) => bb.get('formData.loanType') === 'personal',
        '检查是否为个人贷款'
      ),

      // 个人贷款特定流程
      new SequenceNode([
        this.buildEmploymentInfoStep(),
        this.buildIncomeVerificationStep(),
        this.buildCreditCheckStep()
      ])
    ]);
  }

  private buildBusinessLoanFlow(): BehaviorTreeNode {
    return new SequenceNode([
      new ConditionNode(
        (bb) => bb.get('formData.loanType') === 'business',
        '检查是否为企业贷款'
      ),

      // 企业贷款特定流程
      new SequenceNode([
        this.buildBusinessInfoStep(),
        this.buildFinancialStatementStep(),
        this.buildCollateralAssessmentStep()
      ])
    ]);
  }

  private buildSubmissionStep(): BehaviorTreeNode {
    return new SequenceNode([
      new ConditionNode(
        (bb) => bb.get('currentStep') === 'submission',
        '检查是否在提交步骤'
      ),

      // 最终验证
      new ConditionNode(
        (bb) => this.finalValidation(bb.get('formData')),
        '最终数据验证'
      ),

      // 异步提交
      new ActionNode(async (bb) => {
        bb.set('isSubmitting', true);

        try {
          await this.submitApplication(bb.get('formData'));
          bb.set('applicationStatus', 'submitted');
          return NodeStatus.SUCCESS;
        } catch (error) {
          bb.set('submissionError', error.message);
          return NodeStatus.FAILURE;
        } finally {
          bb.set('isSubmitting', false);
        }
      }, '提交贷款申请')
    ]);
  }

  // 验证方法
  private validateName(name: string): boolean {
    return name && name.length >= 2;
  }

  private validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  private validateAge(age: number): boolean {
    return age >= 18 && age <= 100;
  }

  private finalValidation(formData: any): boolean {
    // 复杂的跨字段验证逻辑
    return true;
  }

  private async submitApplication(data: any): Promise<void> {
    // 模拟API调用
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() > 0.2) {
          resolve();
        } else {
          reject(new Error('提交失败，请重试'));
        }
      }, 2000);
    });
  }

  // UI更新方法
  private updateUI() {
    // 在实际应用中，这里会触发React组件更新
    console.log('更新UI以反映新状态');
  }

  // 公共API
  async processStep(): Promise<boolean> {
    const status = await this.behaviorTree.tick(this.blackboard);
    return status === NodeStatus.SUCCESS;
  }

  setFormData(path: string, value: any) {
    const currentData = this.blackboard.get('formData', {});
    // 使用lodash.set类似的逻辑
    this.setNestedValue(currentData, path, value);
    this.blackboard.set('formData', currentData);
  }

  private setNestedValue(obj: any, path: string, value: any) {
    const keys = path.split('.');
    let current = obj;

    for (let i = 0; i < keys.length - 1; i++) {
      if (!current[keys[i]]) {
        current[keys[i]] = {};
      }
      current = current[keys[i]];
    }

    current[keys[keys.length - 1]] = value;
  }
}
```

### **4.2 动态行为树构建**

```tsx
// 动态行为树构建器
class DynamicBehaviorTreeBuilder {
  private blackboard: Blackboard;

  constructor(blackboard: Blackboard) {
    this.blackboard = blackboard;
  }

  // 基于配置动态构建行为树
  buildFromConfig(config: BehaviorTreeConfig): BehaviorTreeNode {
    return this.buildNode(config.root);
  }

  private buildNode(nodeConfig: NodeConfig): BehaviorTreeNode {
    switch (nodeConfig.type) {
      case 'selector':
        return new SelectorNode(
          nodeConfig.children.map(child => this.buildNode(child))
        );

      case 'sequence':
        return new SequenceNode(
          nodeConfig.children.map(child => this.buildNode(child))
        );

      case 'parallel':
        return new ParallelNode(
          nodeConfig.children.map(child => this.buildNode(child)),
          nodeConfig.successThreshold,
          nodeConfig.failureThreshold
        );

      case 'condition':
        return new ConditionNode(
          this.createConditionFunction(nodeConfig.condition),
          nodeConfig.description
        );

      case 'action':
        return new ActionNode(
          this.createActionFunction(nodeConfig.action),
          nodeConfig.description
        );

      case 'inverter':
        return new InverterNode(
          this.buildNode(nodeConfig.child)
        );

      case 'repeater':
        return new RepeaterNode(
          this.buildNode(nodeConfig.child),
          nodeConfig.times
        );

      case 'wait':
        return new WaitNode(nodeConfig.duration);

      default:
        throw new Error(`未知节点类型: ${nodeConfig.type}`);
    }
  }

  private createConditionFunction(conditionConfig: ConditionConfig): (bb: Blackboard) => boolean {
    return (blackboard: Blackboard) => {
      // 解析复杂的条件表达式
      return this.evaluateCondition(conditionConfig, blackboard);
    };
  }

  private evaluateCondition(condition: ConditionConfig, blackboard: Blackboard): boolean {
    if (condition.operator === 'and') {
      return condition.conditions!.every(cond => this.evaluateCondition(cond, blackboard));
    }

    if (condition.operator === 'or') {
      return condition.conditions!.some(cond => this.evaluateCondition(cond, blackboard));
    }

    if (condition.operator === 'not') {
      return !this.evaluateCondition(condition.condition!, blackboard);
    }

    // 基本比较操作
    const leftValue = this.getValue(condition.left, blackboard);
    const rightValue = this.getValue(condition.right, blackboard);

    switch (condition.operator) {
      case 'eq': return leftValue === rightValue;
      case 'neq': return leftValue !== rightValue;
      case 'gt': return leftValue > rightValue;
      case 'gte': return leftValue >= rightValue;
      case 'lt': return leftValue < rightValue;
      case 'lte': return leftValue <= rightValue;
      case 'in': return Array.isArray(rightValue) && rightValue.includes(leftValue);
      default: return false;
    }
  }

  private getValue(valueConfig: ValueConfig, blackboard: Blackboard): any {
    if (valueConfig.type === 'literal') {
      return valueConfig.value;
    }

    if (valueConfig.type === 'blackboard') {
      return blackboard.get(valueConfig.path);
    }

    if (valueConfig.type === 'function') {
      return this.executeFunction(valueConfig.function, blackboard);
    }

    return undefined;
  }

  private executeFunction(funcConfig: FunctionConfig, blackboard: Blackboard): any {
    // 执行预定义的函数
    const functions: Record<string, Function> = {
      'arrayLength': (arr: any[]) => arr?.length || 0,
      'stringLength': (str: string) => str?.length || 0,
      'isEmpty': (value: any) => {
        if (Array.isArray(value)) return value.length === 0;
        if (typeof value === 'string') return value.length === 0;
        if (typeof value === 'object') return Object.keys(value).length === 0;
        return !value;
      }
    };

    const func = functions[funcConfig.name];
    if (!func) {
      throw new Error(`未知函数: ${funcConfig.name}`);
    }

    const args = funcConfig.arguments.map(arg => this.getValue(arg, blackboard));
    return func(...args);
  }

  private createActionFunction(actionConfig: ActionConfig): (bb: Blackboard) => Promise<NodeStatus> | NodeStatus {
    return async (blackboard: Blackboard) => {
      try {
        // 执行动作逻辑
        await this.executeAction(actionConfig, blackboard);
        return NodeStatus.SUCCESS;
      } catch (error) {
        console.error('动作执行失败:', error);
        return NodeStatus.FAILURE;
      }
    };
  }

  private async executeAction(actionConfig: ActionConfig, blackboard: Blackboard): Promise<void> {
    const actions: Record<string, Function> = {
      'setBlackboardValue': (path: string, value: any) => {
        blackboard.set(path, value);
      },

      'navigateToStep': (step: string) => {
        blackboard.set('currentStep', step);
      },

      'showModal': (modalId: string) => {
        // 在实际应用中触发模态框显示
        console.log(`显示模态框: ${modalId}`);
      },

      'apiCall': async (endpoint: string, data: any) => {
        // 执行API调用
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });

        if (!response.ok) {
          throw new Error(`API调用失败: ${response.statusText}`);
        }

        return response.json();
      }
    };

    const action = actions[actionConfig.name];
    if (!action) {
      throw new Error(`未知动作: ${actionConfig.name}`);
    }

    const args = actionConfig.arguments.map(arg => this.getValue(arg, blackboard));
    await action(...args);
  }
}

// 配置驱动的方式定义行为树
const loanApplicationConfig: BehaviorTreeConfig = {
  root: {
    type: 'sequence',
    children: [
      {
        type: 'sequence',
        children: [
          {
            type: 'condition',
            condition: {
              operator: 'eq',
              left: { type: 'blackboard', path: 'currentStep' },
              right: { type: 'literal', value: 'basicInfo' }
            }
          },
          {
            type: 'sequence',
            children: [
              // 验证逻辑...
            ]
          }
        ]
      }
      // 更多步骤...
    ]
  }
};
```