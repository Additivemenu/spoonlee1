# 六、调试与监控体系

### **6.1 可视化调试工具**

```tsx

// 行为树可视化调试器
class BehaviorTreeDebugger {
  private executionHistory: Array<{
    timestamp: number;
    node: string;
    status: NodeStatus;
    blackboardSnapshot: any;
  }> = [];

  // 节点执行监控
  wrapNode(node: BehaviorTreeNode, name: string): BehaviorTreeNode {
    const self = this;

    return new (class extends BehaviorTreeNode {
      async tick(blackboard: Blackboard): Promise<NodeStatus> {
        const startTime = Date.now();

        self.recordExecutionStart(name, blackboard);

        try {
          const status = await node.tick(blackboard);
          self.recordExecutionEnd(name, status, blackboard, Date.now() - startTime);
          return status;
        } catch (error) {
          self.recordExecutionError(name, error, blackboard);
          throw error;
        }
      }
    })();
  }

  private recordExecutionStart(nodeName: string, blackboard: Blackboard) {
    this.executionHistory.push({
      timestamp: Date.now(),
      node: nodeName,
      status: NodeStatus.RUNNING,
      blackboardSnapshot: this.snapshotBlackboard(blackboard)
    });
  }

  private recordExecutionEnd(nodeName: string, status: NodeStatus, blackboard: Blackboard, duration: number) {
    this.executionHistory.push({
      timestamp: Date.now(),
      node: nodeName,
      status,
      blackboardSnapshot: this.snapshotBlackboard(blackboard),
      duration
    });
  }

  private snapshotBlackboard(blackboard: Blackboard): any {
    // 创建黑板的浅拷贝用于调试
    return { ...blackboard };
  }

  // 生成执行报告
  generateExecutionReport(): ExecutionReport {
    const successfulNodes = this.executionHistory.filter(
      record => record.status === NodeStatus.SUCCESS
    );

    const failedNodes = this.executionHistory.filter(
      record => record.status === NodeStatus.FAILURE
    );

    const runningTimes = this.calculateNodeRunningTimes();

    return {
      totalExecutions: this.executionHistory.length,
      successRate: successfulNodes.length / this.executionHistory.length,
      performanceMetrics: runningTimes,
      criticalPath: this.identifyCriticalPath(),
      recommendations: this.generateOptimizationSuggestions()
    };
  }

  // 实时可视化
  createLiveVisualization(): HTMLElement {
    const container = document.createElement('div');
    container.className = 'bt-debugger';

    // 创建树状可视化
    this.renderTreeVisualization(container);

    // 创建执行时间线
    this.renderTimeline(container);

    // 创建黑板数据监视器
    this.renderBlackboardMonitor(container);

    return container;
  }
}
```

### **6.2 性能监控与优化**

```tsx
// 行为树性能分析器
class BTPerformanceAnalyzer {
  private metrics: Map<string, NodeMetrics> = new Map();

  recordNodeExecution(nodeId: string, duration: number, success: boolean) {
    if (!this.metrics.has(nodeId)) {
      this.metrics.set(nodeId, {
        executionCount: 0,
        totalDuration: 0,
        successCount: 0,
        failureCount: 0,
        averageDuration: 0
      });
    }

    const metrics = this.metrics.get(nodeId)!;
    metrics.executionCount++;
    metrics.totalDuration += duration;
    metrics.averageDuration = metrics.totalDuration / metrics.executionCount;

    if (success) {
      metrics.successCount++;
    } else {
      metrics.failureCount++;
    }
  }

  identifyBottlenecks(): BottleneckReport[] {
    const bottlenecks: BottleneckReport[] = [];

    for (const [nodeId, metrics] of this.metrics) {
      if (metrics.averageDuration > 100) { // 超过100ms认为可能有问题
        bottlenecks.push({
          nodeId,
          averageDuration: metrics.averageDuration,
          executionCount: metrics.executionCount,
          impact: this.calculateImpact(metrics),
          suggestion: this.generateSuggestion(metrics)
        });
      }
    }

    return bottlenecks.sort((a, b) => b.impact - a.impact);
  }

  private calculateImpact(metrics: NodeMetrics): number {
    // 计算节点对整体性能的影响
    return metrics.averageDuration * metrics.executionCount;
  }

  generateOptimizationPlan(): OptimizationPlan {
    const bottlenecks = this.identifyBottlenecks();

    return {
      highPriority: bottlenecks.filter(b => b.impact > 1000),
      mediumPriority: bottlenecks.filter(b => b.impact > 100 && b.impact <= 1000),
      lowPriority: bottlenecks.filter(b => b.impact <= 100),
      estimatedSavings: this.calculateEstimatedSavings(bottlenecks)
    };
  }
}
```