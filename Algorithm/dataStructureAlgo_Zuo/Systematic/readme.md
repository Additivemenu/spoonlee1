体系学习班 P62-150
2022-7-28开始学
# Class1
## p62 常数操作
常数操作耗费固定时间 
+ 比如两个32位的int数相加, 甭管是1+1还是1300+15666, 耗费的时间是一样的
+ 数组寻址, 如一个长度为1000万的数组, 索引它的第200万个元素和索引它第800万个元素耗时几乎是一样的的, 因为数组是在内存中逻辑上是连续结构的, 通过计算偏移量来索引. 而Linkedlist这种跳转结构在寻址上耗费的时间不是固定的, 取决于节点所在的位置.

常见的常数时间操作:
+ 算数运算(+, -, *, /, %等)
+ 位运算(>>, >>>, <<, |, &, ^等)
+ 赋值, 比较, 自增, 自减操作等
+ 数组寻址操作

总之, 执行时间固定的操作都是常数时间操作;
反之, 执行时间不固定的操作, 都不是常数时间操作. 在算法分析中, 应将非常数时间操作继续分解为常数时间操作, 再进行复杂度分析. 比如链表list.get()方法其实每次都是从0node开始寻址到目标node, 它并不是常数时间操作, 它本身的时间复杂度就是O(N).

## p63 时间复杂度
算法复杂度分析: 分解到常数操作(最基本的单元)

以选择排序为例分析:
1) 第一小步: 遍历N个数(需N次), 找到最小值(需N-1次比较)
   第二小步: 将最小值放在0位置(需O(1))
2) 第一小步: 遍历剩下的N-1个数(需N-1次), 找到最小值(需N-2次比较)
   第二小步: 将最小值放在1位置
   ...

最后需要 $aN^2+bN+c$ (a,b,c是常数, 等差数列求和肯定是二次函数的形式)次常数操作
时间复杂度: 只取最高项, 舍弃最高项系数, 这里即O($N^2$); 时间复杂度描述的是算法流程的总操作数和数据量之间的关系.

## p64 选择排序,冒泡排序
评估算法优劣的核心指标:
+ 时间复杂度(流程决定)
+ 额外空间复杂度(流程决定)
+ 常数项时间(实现细节决定)

[selectSorting](../beginner/class1/Code07_SelectionSorting.java)
O($N^2$)

[bubbleSorting](../beginner/class1/Code08_bubbleSort.java)
O($N^2$)

## p65 插入排序
[insertSorting](../beginner/class1/Code09_insertSort.java)
**不同于选择排序和冒泡排序, 此时时间复杂度与数据的分布状况有关,用最差情况来估计**
(面试阶段不用学平均和最好时间复杂度)


## p66 插入排序的代码


## p67 额外的空间复杂度


## p68 算法流程的常数项



## p69 算法的最优解


## p70 对数器的认识



# Class2





# Class3
## p81